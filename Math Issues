Oh no, our Math object was "accidently" reset. Can you re-implement some of those functions? We can assure, that only non-negative numbers are passed as arguments. So you don't have to consider things like undefined, null, NaN, negative numbers, strings and so on.

Here is a list of functions, we need:

Math.round()
Math.ceil()
Math.floor()

Math.round = function(number) {
  return 0; // TODO: fix this
};

Math.ceil = function(number) {
  return 0; // TODO: fix this
};

Math.floor = function(number) {
  return 0; // TODO: fix this
};

My Solution:

Math.round = function(number) {
  let replace = number.toString().replace(/[.]/gi, ',.')
  let split = replace.split(',');
  if (split.length === 1) return parseInt(split[0]);
  return parseFloat(split[1]) < 0.5 ? parseInt(split[0]) : parseInt(split[0])+1;
};

Math.ceil = function(number) {
  let replace = number.toString().replace(/[.]/gi, ',.')
  let split = replace.split(',');
  return split.length === 1 ? parseInt(split[0]) : parseInt(split[0]) + 1;
};

Math.floor = function(number) {
  let replace = number.toString().replace(/[.]/gi, ',.')
  let split = replace.split(',');
  return parseInt(split[0]);
};

Best Solution:

Math.round = function(number) {
  return (number - parseInt(number) >= 0.5) ? parseInt(number) + 1 : parseInt(number) ;
};

Math.ceil = function(number) {
  return (parseInt(number) === number) ? number : parseInt(number) + 1;
};

Math.floor = function(number) {
  return parseInt(number);
};

Walkthough of Best Solution:
